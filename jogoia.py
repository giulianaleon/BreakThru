# -*- coding: utf-8 -*-
"""JogoIA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QFyoSJSYpIOUHidn_k_mNyU4mGxMZlzm
"""

import math

board = [
    [0,0,1,1,1,0,0],
    [0,0,0,0,0,0,0],
    [1,0,2,2,2,0,1],
    [1,0,2,3,2,0,1],
    [1,0,2,2,2,0,1],
    [0,0,0,0,0,0,0],
    [0,0,1,1,1,0,0]
    ]

#Jogadores
MAX_PLAYER = 1
MIN_PLAYER = 2

#Tamanho máximo
MAX_DEPTH = 5

#Valores derrota e vitoria
LOSE_VALUE = -1000
WIN_VALUE = 1000

#Função para exibir o tabuleiro
def display_board(board):
      for row in board:
        for cell in row:
            print(cell, end=' ')
        print()

#Função de avaliação simples para o estado do jogo
def evaluate(board):
    # Contagem de peças do jogador MAX_PLAYER
    max_pieces = sum([row.count(MAX_PLAYER) for row in board])

    # Contagem de peças do jogador MIN_PLAYER
    min_pieces = sum([row.count(MIN_PLAYER) for row in board])

    galeao = any(3 in linha for linha in board)
    # Se o jogador MAX_PLAYER venceu
    if max_pieces == 0 or not(galeao):
        return LOSE_VALUE

    # Se o jogador MIN_PLAYER venceu
    if min_pieces == 0 or gold_Win(board):
        return WIN_VALUE

     #Valor de avaliação intermediário
    eval_value = max_pieces - min_pieces
    return eval_value

#Verifica se ouro ganha
def gold_Win(board):
#Verifica se ouro chegou em alguma das bordas
  for i in range(6):
    if board[0][i] == 2 or board[6][i] == 2 or board[i][0] == 2 or board[i][6] == 2:
        return True

    if board[0][i] == 3 or board[6][i] == 3 or board[i][0] == 3 or board[i][6] == 3:
        return True

  return False

def game_over(board):
    # Verificar se o jogador MAX_PLAYER venceu
    if sum([row.count(MAX_PLAYER) for row in board]) == 0:
        return True

    #embarcação principal ainda está no jogo
    if not (any(3 in linha for linha in board)): # Esse nome ainda está provisorio para 3
      return True

    # Verificar se o jogador MIN_PLAYER venceu
    if sum([row.count(MIN_PLAYER) for row in board]) == 0:
        return True

    if gold_Win(board):
      return True

    return False

def generate_moves(board, player, moved):
      moves = []
      if player == 2:
        var = 3
      else: var = player

      for i in range(len(board)-1):
          for j in range(len(board[i])-1):
              if board[i][j] == player or board[i][j] == var and (i, j) not in moves:
                  current_position = (i,j)
                  # Movimentos horizontais e verticais

                  if i > 0 and board[i][j-1] == 0:
                      moves.append((current_position, (i, j-1)))
                  if i < len(board[i])-1 and board[i][j+1] == 0:
                      moves.append((current_position, (i, j+1)))
                  if j > 0 and board[i-1][j] == 0:
                      moves.append((current_position, (i-1, j)))
                  if j < len(board)-1 and board[i+1][j] == 0:
                    moves.append((current_position, (i+1, j)))

                  # Movimentos diagonais para captura

                  if board[i-1][j-1] != player and board[i - 1][j - 1] != 0:
                      moves.append(((i, j), (i - 1, j - 1)))
                  if board[i-1][j+1] != player and board[i - 1][j + 1] != 0:
                      moves.append(((i, j), (i - 1, j + 1)))
                  if board[i+1][j-1] != player and board[i + 1][j - 1] != 0:
                      moves.append(((i, j), (i + 1, j - 1)))
                  if board[i+1][j+1] != player and board[i + 1][j + 1] != 0:
                      moves.append(((i, j), (i + 1, j + 1)))

      return moves

# Função para executar uma jogada no tabuleiro
def make_move(board, move, player, moved):
    start_pos, end_pos = move
    start_row, start_col = start_pos
    end_row, end_col = end_pos
    board[start_row][start_col] = 0
    board[end_row][end_col] = player
    moved.append((end_row,end_col))

# Função minimax com poda alpha-beta
def minimax(board, depth, alpha, beta, maximizing_player, moved):
    if depth == 0 or game_over(board):
        return evaluate(board)

    if maximizing_player:
        max_eval = -math.inf
        moves = generate_moves(board, MAX_PLAYER,moved)
        for move in moves:
            new_board = [row[:] for row in board]
            make_move(new_board, move, MAX_PLAYER, moved)
            eval = minimax(new_board, depth - 1, alpha, beta, False,moved)
            max_eval = max(max_eval, eval)
            alpha = max(alpha, eval)
            if beta <= alpha:
                break
            moved.pop()
        return max_eval
    else:
        min_eval = math.inf
        moves = generate_moves(board, MIN_PLAYER,moved)
        for move in moves:
            new_board = [row[:] for row in board]
            make_move(new_board, move, MIN_PLAYER,moved)
            eval = minimax(new_board, depth - 1, alpha, beta, True, moved)
            min_eval = min(min_eval, eval)
            beta = min(beta, eval)
            if beta <= alpha:
                break
            moved.pop()
        return min_eval

# Função para determinar a melhor jogada usando a busca minimax com poda alpha-beta
def find_best_move(board, player,moved):
    best_eval = -math.inf
    best_move = None

    moves = generate_moves(board, player, moved)
    for move in moves:
        new_board = [row[:] for row in board]
        make_move(new_board, move, player, moved)
        eval = minimax(new_board, MAX_DEPTH, -math.inf, math.inf, False, moved)
        if eval > best_eval:
            best_eval = eval
            best_move = move
    print(best_move)
    return best_move

def fimDeJogo(board):

  print('O vencedor do Jogo foi:\n')
  if gold_Win(board):
    print('Jogador Ouro Ganhou!!!')
  else: print('Jogador Prata Ganhou!!!')

def is_valid_move(board, move, player):
  start_pos, end_pos = move
  row_old, col_old = start_pos
  row_new, col_new = end_pos

  if player == 2:
    prayer = 3
  else: prayer = 1

  if  0 <= row_old <= 6 and 0 <= col_old <= 6 and board[row_old][col_old] == player or board[row_old][col_old] == prayer :
    if 0 <= row_new <= 6 and 0 <= col_new <= 6 and board[row_new][col_new] != player or board[row_old][col_old] == prayer:
          return True

    # if board[row_new-1][col_new-1] != player and board[row_new - 1][col_new - 1] != 0:
    #       return True
    # if board[row_new-1][col_new+1] != player and board[row_new - 1][col_new + 1] != 0:
    #       return True
    # if board[row_new+1][col_new-1] != player and board[row_new + 1][col_new - 1] != 0:
    #       return True
    # if board[row_new+1][col_new+1] != player and board[row_new + 1][col_new + 1] != 0:
    #       return True
    # else:
  print('Essa posição não é possível de se realizar')
  return False

#Função que inicia o Jogo

def inicio(board):

  print("BreakThru\n\n")
  print("Como gostaria de jogar?")
  print("1. Sendo 1(Prata)")
  print("3. Quero que as máquinas joguem entre si")
  comoJogar = input("Vou iniciar o jogo como: ")
  moved = []
  display_board(board)
  posCentro = (3,3)
  move = []
  jogadores = [1,2]


  while(True):

    if comoJogar == '1':
      for i in range(2):
        var = True

        while var:

          start_row = int(input("Digite a linha de origem da peça: "))
          start_col = int(input("Digite a coluna de origem da peça: "))
          end_row = int(input("Digite a linha de destino da peça: "))
          end_col = int(input("Digite a coluna de destino da peça: "))

          move = ((start_row, start_col), (end_row, end_col))

          if is_valid_move(board,move, 1):
            make_move(board, move, 1, moved)

            display_board(board)

            var = is_valid_move(board, move, 1)
            move = []

            if game_over(board):
              break
      for i in range(2):
          new_pos = find_best_move(board, 2,moved)

          if new_pos == posCentro:
            posCentro = new_pos
            make_move(board, new_pos, 2, moved)
            break
          else: make_move(board, new_pos, 2, moved)

          if game_over(board):
            break

          display_board(board)

    if comoJogar == '2':

        for i in range(2):
          var = True

          while var:

            start_row = int(input("Digite a linha de origem da peça: "))
            start_col = int(input("Digite a coluna de origem da peça: "))
            end_row = int(input("Digite a linha de destino da peça: "))
            end_col = int(input("Digite a coluna de destino da peça: "))

            move = ((start_row, start_col), (end_row, end_col))

            if is_valid_move(board,move, 2):
              make_move(board, move, 2, moved)
              display_board(board)
              var = is_valid_move(board, move, 2)
              move = []

              if game_over(board):
                break

        for i in range(2):
          new_pos = find_best_move(board, 1,moved)

          if new_pos == posCentro:
            posCentro = new_pos
            make_move(board, new_pos, 1, moved)
            break
          else: make_move(board, new_pos, 1, moved)

          if game_over(board):
            break

          display_board(board)


    if comoJogar == '3':
      for i in range(2):
        for jogador in jogadores:

          new_pos = find_best_move(board, jogador,moved)
          make_move(board, new_pos, jogador, moved)

          if new_pos == posCentro:
            posCentro = new_pos
            make_move(board, new_pos, jogador, moved)
            break

          if game_over(board):
            break

    if game_over(board):
      fimDeJogo(board)
      break
      print('\n')
    display_board(board)
inicio(board)

display_board(board)